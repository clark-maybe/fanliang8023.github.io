---
layout: post
title: "记忆化斐波那契函数JS实战"
date: 2018-11-13
description: "记忆化斐波那契函数JS实战"
tag: 技术分享
---
    最近在ScriptOJ上刷题，发现一个非常常见的但是容易被忽视的技术点，拿出来跟大家分享一下.


    题干：
    斐波那契数列指的是类似于以下的数列：

    1, 1, 2, 3, 5, 8, 13, ....
    也就是，第 n 个数由数列的前两个相加而来：f(n) = f(n - 1) + f(n -2)

    请你完成 fibonacci 函数，接受 n 作为参数，可以获取数列中第 n 个数，例如：

    fibonacci(1) // => 1
    fibonacci(2) // => 1
    fibonacci(3) // => 2
    ...
    测试程序会从按顺序依次获取斐波那契数列中的数，请注意程序不要超时，也不要添加额外的全局变量。

    本题来源：《JavaScript 语言精髓》



    --------------------------------------------------------------------------------------------------------
    先贴出写法再做解释
    const fibonacci = (n, a=0, b=1) => {
    if(n === 0){
    return a
    }
    return fibonacci(n-1, b, a+b);
    }


    这道题其实考察的是在循环调用的时候下次调用会依赖上次调用的结果，导致栈帧不能被释放，以至于很少的循环次数就会爆栈，
    导致浏览器或者其他运行环境崩溃，在平时书写的时候我可能不会注意到这个问题，但是这个问题很容易会在上线后被无限放大，
    所以我感觉这应该是一个值得关注的点，而且应该在心中时刻注意。

    贴上我第一次写的代码
    const fibonacci = (n) => {
    if(n >= 0 && n<2){
    return n;
    }
    return fibonacci(n-2) + fibonacci(n-1);
    }

    我的这种写法就会直接爆栈导致浏览器崩掉，so， 各位小伙伴要注意哈，这就是这次分享的全部内容，感谢观看.


